<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素工房 - 現代圖像編輯器</title>
    <!-- Tailwind CSS v3 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#8B5CF6',
                        secondary: '#7C3AED',
                        dark: '#1A1D2A',
                        darker: '#12141F',
                        light: '#F7F9FC',
                        accent: '#EC4899',
                        'primary-light': '#A78BFA',
                        'gray-light': '#E2E8F0',
                        'gray-medium': '#94A3B8',
                        'gray-dark': '#334155'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    boxShadow: {
                        'inner-lg': 'inset 0 2px 10px 0 rgba(0, 0, 0, 0.15)',
                        'glass': '0 8px 32px rgba(0, 0, 0, 0.1)',
                        'button': '0 2px 4px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)'
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.2s ease-in-out',
                        'slide-up': 'slideUp 0.3s ease-out',
                        'pulse-subtle': 'pulseSubtle 2s infinite'
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' }
                        },
                        slideUp: {
                            '0%': { transform: 'translateY(10px)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' }
                        },
                        pulseSubtle: {
                            '0%, 100%': { opacity: '1' },
                            '50%': { opacity: '0.8' }
                        }
                    }
                }
            },
            darkMode: 'class'
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .scrollbar-hide::-webkit-scrollbar {
                display: none;
            }
            .scrollbar-hide {
                -ms-overflow-style: none;
                scrollbar-width: none;
            }
            .glass-effect {
                @apply bg-white/10 backdrop-blur-md border border-white/20;
            }
            .glass-effect-dark {
                @apply bg-dark/80 backdrop-blur-md border border-white/10;
            }
            .glass-effect-light {
                @apply bg-white/70 backdrop-blur-md border border-gray-200/50;
            }
            .tool-button {
                @apply flex flex-col items-center justify-center p-4 rounded-xl transition-all duration-200 hover:bg-white/10 hover:shadow-button active:bg-white/20 active:scale-95;
            }
            .tool-button.active {
                @apply bg-primary/20 text-primary ring-1 ring-primary/30;
            }
            .slider-track {
                @apply h-1.5 rounded-full bg-white/20;
            }
            .slider-thumb {
                @apply w-5 h-5 rounded-full bg-primary shadow-lg cursor-pointer hover:shadow-lg hover:scale-110 transition-all;
            }
            .filter-preview {
                @apply w-14 h-14 rounded-lg cursor-pointer transition-all duration-200 hover:scale-105 active:scale-95 overflow-hidden border-2 border-transparent hover:border-primary/50;
            }
            .filter-preview.active {
                @apply border-primary ring-1 ring-primary/30;
            }
            .panel-section {
                @apply mb-6 animate-fade-in;
            }
            .panel-title {
                @apply text-sm font-medium text-gray-medium mb-3 uppercase tracking-wider;
            }
            .btn {
                @apply px-4 py-2 rounded-lg transition-all duration-200 font-medium shadow-button hover:shadow-lg;
            }
            .btn-primary {
                @apply bg-primary text-white hover:bg-secondary active:bg-secondary/90;
            }
            .btn-secondary {
                @apply bg-white/10 text-white hover:bg-white/20 active:bg-white/30;
            }
            .btn-ghost {
                @apply bg-transparent text-white/80 hover:bg-white/10 active:bg-white/20;
            }
            .input-field {
                @apply w-full bg-white/5 border border-white/10 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary/50 transition-all;
            }
            .aspect-btn {
                @apply px-3 py-1.5 rounded-lg transition-all duration-200 text-sm font-medium hover:bg-white/20 active:bg-white/30;
            }
            .aspect-btn.active {
                @apply bg-primary/20 text-primary ring-1 ring-primary/30;
            }
            .tooltip {
                @apply absolute invisible opacity-0 bg-dark text-white text-xs rounded-md py-1 px-2 -mt-12 transition-all duration-200 whitespace-nowrap z-50;
            }
            .has-tooltip:hover .tooltip {
                @apply visible opacity-100;
            }
        }
    </style>
</head>
<body class="bg-darker text-light min-h-screen flex flex-col overflow-hidden">
    <!-- Header -->
    <header class="bg-dark border-b border-white/10 py-2 px-6 shadow-md">
        <div class="flex items-center justify-between max-w-7xl mx-auto w-full">
            <!-- Left side - empty for balance -->
            <div class="w-64"></div>
            
            <!-- Center - Logo and Title -->
            <div class="flex items-center space-x-3 flex-shrink-0">
                <div class="w-12 h-12 rounded-xl bg-gradient-to-br from-primary to-primary-light flex items-center justify-center shadow-lg">
                    <i class="fa fa-paint-brush text-white text-2xl"></i>
                </div>
                <h1 class="text-2xl font-bold bg-gradient-to-r from-white to-gray-300 bg-clip-text text-transparent">像素工房</h1>
            </div>
            
            <!-- Right side - Action buttons -->
            <div class="flex items-center space-x-3 justify-end">
                <button id="newImageBtn" class="btn btn-secondary flex items-center space-x-2">
                    <i class="fa fa-plus text-lg"></i>
                    <span>新建</span>
                </button>
                <button id="openImageBtn" class="btn btn-secondary flex items-center space-x-2">
                    <i class="fa fa-folder-open text-lg"></i>
                    <span>開啟</span>
                </button>
                <input type="file" id="fileInput" accept="image/*" class="hidden">
                <button id="saveImageBtn" class="btn btn-primary flex items-center space-x-2">
                    <i class="fa fa-download text-lg"></i>
                    <span>匯出</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex overflow-hidden">
        <!-- Left Toolbar -->
        <div class="w-20 bg-dark border-r border-white/10 flex flex-col items-center py-6 shadow-lg">
            <div class="w-10 border-t border-white/10 my-2"></div>
            
            <div class="flex flex-col items-center space-y-6">
                <div class="has-tooltip">
                    <div class="tooltip">裁剪</div>
                    <button class="tool-button active" data-tool="crop">
                        <i class="fa fa-crop text-2xl"></i>
                    </button>
                </div>
                <div class="has-tooltip">
                    <div class="tooltip">調整大小</div>
                    <button class="tool-button" data-tool="resize">
                        <i class="fa fa-arrows-alt text-2xl"></i>
                    </button>
                </div>
                <div class="has-tooltip">
                    <div class="tooltip">旋轉與翻轉</div>
                    <button class="tool-button" data-tool="rotate-flip">
                        <i class="fa fa-refresh text-2xl"></i>
                    </button>
                </div>
            </div>
            
            <div class="w-10 border-t border-white/10 my-2"></div>
            
            <div class="flex flex-col items-center space-y-6">
                <div class="has-tooltip">
                    <div class="tooltip">調整</div>
                    <button class="tool-button" data-tool="adjust">
                        <i class="fa fa-sliders text-2xl"></i>
                    </button>
                </div>
                <div class="has-tooltip">
                    <div class="tooltip">濾鏡</div>
                    <button class="tool-button" data-tool="filter">
                        <i class="fa fa-magic text-2xl"></i>
                    </button>
                </div>
                <div class="has-tooltip">
                    <div class="tooltip">新增文字</div>
                    <button class="tool-button" data-tool="text">
                        <i class="fa fa-font text-2xl"></i>
                    </button>
                </div>
                <div class="has-tooltip">
                    <div class="tooltip">AI背景移除</div>
                    <button class="tool-button" data-tool="ai">
                        <i class="fa fa-magic text-2xl"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Center Canvas Area -->
        <div class="flex-1 flex items-center justify-center bg-gradient-to-br from-darker to-dark relative overflow-auto">
            <!-- Background Pattern -->
            <div class="absolute inset-0 opacity-5">
                <div class="absolute inset-0" style="background-image: radial-gradient(#ffffff 1px, transparent 1px); background-size: 20px 20px;"></div>
            </div>
            
            <div id="dropArea" class="absolute inset-0 flex flex-col items-center justify-center border-2 border-dashed border-white/20 rounded-xl m-6 transition-all duration-300 hover:border-primary/50 hover:bg-white/5">
                <div class="text-center p-8 rounded-xl glass-effect-dark animate-fade-in">
                    <div class="w-20 h-20 mx-auto mb-6 rounded-full bg-primary/20 flex items-center justify-center">
                        <i class="fa fa-cloud-upload text-4xl text-primary"></i>
                    </div>
                    <h2 class="text-2xl font-bold mb-3">上傳您的圖片</h2>
                    <p class="text-white/70 mb-6 max-w-md">拖放圖片至於此或點擊從電腦瀏覽</p>
                    <button id="uploadBtn" class="px-6 py-3 bg-primary hover:bg-secondary rounded-lg transition-all duration-300 shadow-lg hover:shadow-xl active:scale-95">
                        選擇圖片
                    </button>
                </div>
            </div>
            
            <div id="canvasContainer" class="relative hidden animate-fade-in p-8 max-w-full max-h-full flex flex-col items-center">
                <!-- Floating action buttons -->
                <div class="absolute top-4 left-1/2 transform -translate-x-1/2 z-10 flex space-x-3 bg-dark/80 backdrop-blur-md rounded-full px-4 py-2 shadow-lg border border-white/10 animate-fade-in">
                    <div class="has-tooltip">
                        <div class="tooltip">復原</div>
                        <button class="tool-button bg-white/10 hover:bg-white/20 p-3 rounded-full" data-tool="undo">
                            <i class="fa fa-undo text-xl"></i>
                        </button>
                    </div>
                    <div class="has-tooltip">
                        <div class="tooltip">重做</div>
                        <button class="tool-button bg-white/10 hover:bg-white/20 p-3 rounded-full" data-tool="redo">
                            <i class="fa fa-repeat text-xl"></i>
                        </button>
                    </div>
                    <div class="has-tooltip">
                        <div class="tooltip">重置</div>
                        <button class="tool-button bg-white/10 hover:bg-white/20 p-3 rounded-full" data-tool="reset">
                            <i class="fa fa-refresh text-xl"></i>
                        </button>
                    </div>
                </div>
                
                <div class="relative rounded-xl overflow-hidden shadow-2xl border border-white/10 bg-white/5 mt-16">
                    <canvas id="imageCanvas" class="block max-w-full max-h-[calc(100vh-200px)]"></canvas>
                    <div id="canvasOverlay" class="absolute inset-0 pointer-events-none"></div>
                </div>
            </div>
            
            <div id="loadingOverlay" class="absolute inset-0 bg-black/70 flex items-center justify-center z-50 hidden">
                <div class="text-center p-8 rounded-xl glass-effect-dark animate-fade-in">
                    <div class="inline-block animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-primary mb-6"></div>
                    <p id="loadingText" class="text-xl font-medium">處理中...</p>
                </div>
            </div>
        </div>

        <!-- Right Properties Panel -->
        <div id="propertiesPanel" class="w-72 bg-dark border-l border-white/10 p-6 overflow-y-auto hidden animate-slide-up">
            <div id="panelContent">
                <!-- Dynamic content based on selected tool -->
            </div>
        </div>
    </main>

    <!-- 匯出 Modal -->
    <div id="exportModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-50 hidden">
        <div class="bg-dark border border-white/20 rounded-lg p-6 w-80">
            <h3 class="text-xl font-bold mb-4">匯出</h3>
            
            <div class="mb-4">
                <label class="block text-sm text-white/70 mb-1">格式</label>
                <select id="exportFormat" class="w-full bg-white/10 border border-white/20 rounded-md px-3 py-2">
                    <option value="image/png">PNG格式</option>
                    <option value="image/jpeg">JPEG格式</option>
                </select>
            </div>
            
            <div class="mb-4">
                <label class="block text-sm text-white/70 mb-1">品質</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="exportQuality" min="0.1" max="1" step="0.1" value="1" class="flex-1">
                    <span id="qualityValue" class="text-sm w-8">100%</span>
                </div>
            </div>
            
            <div class="flex space-x-2 mt-6">
                <button id="cancel匯出Btn" class="flex-1 px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors">
                    取消
                </button>
                <button id="confirm匯出Btn" class="flex-1 px-3 py-2 bg-primary hover:bg-secondary rounded-md transition-colors">
                    匯出
                </button>
            </div>
        </div>
    </div>

    <!-- Text Editor Modal -->
    <div id="textModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-50 hidden">
        <div class="bg-dark border border-white/20 rounded-lg p-6 w-96">
            <h3 class="text-xl font-bold mb-4">新增文字</h3>
            
            <div class="mb-4">
                <label class="block text-sm text-white/70 mb-1">文字</label>
                <input type="text" id="textInput" class="w-full bg-white/10 border border-white/20 rounded-md px-3 py-2" placeholder="在此輸入文字...">
            </div>
            
            <div class="mb-4">
                <label class="block text-sm text-white/70 mb-1">字體</label>
                <select id="fontFamily" class="w-full bg-white/10 border border-white/20 rounded-md px-3 py-2">
                    <option value="Arial, sans-serif">亞洲體</option>
                    <option value="'Times 新建 Roman', serif">新細明體</option>
                    <option value="'Courier 新建', monospace">等寬</option>
                    <option value="Georgia, serif">喬治亞</option>
                    <option value="Verdana, sans-serif">微軟正黑體</option>
                </select>
            </div>
            
            <div class="mb-4">
                <label class="block text-sm text-white/70 mb-1">字體大小</label>
                <input type="number" id="fontSize" class="w-full bg-white/10 border border-white/20 rounded-md px-3 py-2" value="24" min="8" max="120">
            </div>
            
            <div class="mb-4">
                <label class="block text-sm text-white/70 mb-1">文字顏色</label>
                <input type="color" id="fontColor" class="w-full h-10 bg-white/10 border border-white/20 rounded-md cursor-pointer" value="#ffffff">
            </div>
            
            <div class="mb-4">
                <label class="block text-sm text-white/70 mb-1">樣式</label>
                <div class="flex space-x-2">
                    <button id="boldBtn" class="px-3 py-1.5 rounded-md bg-white/10 hover:bg-white/20 transition-colors">
                        <i class="fa fa-bold"></i>
                    </button>
                    <button id="italicBtn" class="px-3 py-1.5 rounded-md bg-white/10 hover:bg-white/20 transition-colors">
                        <i class="fa fa-italic"></i>
                    </button>
                    <button id="underlineBtn" class="px-3 py-1.5 rounded-md bg-white/10 hover:bg-white/20 transition-colors">
                        <i class="fa fa-underline"></i>
                    </button>
                </div>
            </div>
            
            <div class="flex space-x-2 mt-6">
                <button id="cancelTextBtn" class="flex-1 px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors">
                    取消
                </button>
                <button id="confirmTextBtn" class="flex-1 px-3 py-2 bg-primary hover:bg-secondary rounded-md transition-colors">
                    新增文字
                </button>
            </div>
        </div>
    </div>

    <!-- AI背景移除 Modal -->
    <div id="aiModal" class="fixed inset-0 bg-black/70 flex items-center justify-center z-50 hidden">
        <div class="bg-dark border border-white/20 rounded-lg p-6 w-96">
            <h3 class="text-xl font-bold mb-4">AI背景移除</h3>
            
            <div class="mb-6">
                <p class="text-white/70 mb-4">此功能將使用AI技術自動移除圖片背景。</p>
                <div class="flex items-center space-x-2 text-sm text-yellow-400">
                    <i class="fa fa-info-circle"></i>
                    <span>此為模擬AI功能，僅供演示使用。</span>
                </div>
            </div>
            
            <div class="flex space-x-2">
                <button id="cancelAiBtn" class="flex-1 px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors">
                    取消
                </button>
                <button id="confirmAiBtn" class="flex-1 px-3 py-2 bg-primary hover:bg-secondary rounded-md transition-colors">
                    移除背景
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas, ctx;
        let originalImage = null;
        let currentImage = null;
        let imageData = null;
        let textObjects = [];
        let history = [];
        let historyIndex = -1;
        let currentTool = 'none';
        let cropStart = { x: 0, y: 0 };
        let cropEnd = { x: 0, y: 0 };
        let isDragging = false;
        let selectedTextIndex = -1;
        
        // Filter presets
        const filterPresets = [
            { name: '正常', values: { brightness: 0, contrast: 0, saturation: 0, grayscale: 0, sepia: 0 } },
            { name: '懷舊', values: { brightness: 10, contrast: -10, saturation: -20, grayscale: 0, sepia: 50 } },
            { name: '黑白', values: { brightness: 0, contrast: 20, saturation: -100, grayscale: 100, sepia: 0 } },
            { name: '鮮豔', values: { brightness: 10, contrast: 15, saturation: 40, grayscale: 0, sepia: 0 } },
            { name: '戲劇', values: { brightness: -10, contrast: 30, saturation: 10, grayscale: 0, sepia: 0 } },
            { name: '冷色', values: { brightness: 0, contrast: 0, saturation: 0, grayscale: 0, sepia: 0, hue: 180 } },
            { name: '暖色', values: { brightness: 10, contrast: 0, saturation: 20, grayscale: 0, sepia: 30 } },
            { name: '模糊', values: { blur: 5 } }
        ];
        
        // DOM Elements
        const dropArea = document.getElementById('dropArea');
        const canvasContainer = document.getElementById('canvasContainer');
        const imageCanvas = document.getElementById('imageCanvas');
        const canvasOverlay = document.getElementById('canvasOverlay');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const propertiesPanel = document.getElementById('propertiesPanel');
        const panelContent = document.getElementById('panelContent');
        const fileInput = document.getElementById('fileInput');
        const exportModal = document.getElementById('exportModal');
        const textModal = document.getElementById('textModal');
        const aiModal = document.getElementById('aiModal');
        
        // Initialize the application
        function init() {
            canvas = document.getElementById('imageCanvas');
            ctx = canvas.getContext('2d');
            
            // Event Listeners
            document.getElementById('uploadBtn').addEventListener('click', () => fileInput.click());
            document.getElementById('openImageBtn').addEventListener('click', () => fileInput.click());
            document.getElementById('newImageBtn').addEventListener('click', newImage);
            document.getElementById('saveImageBtn').addEventListener('click', show匯出Modal);
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            
            // 匯出 Modal Events
            document.getElementById('exportFormat').addEventListener('change', updateQualityVisibility);
            document.getElementById('exportQuality').addEventListener('input', updateQualityValue);
            document.getElementById('cancel匯出Btn').addEventListener('click', () => exportModal.classList.add('hidden'));
            document.getElementById('confirm匯出Btn').addEventListener('click', exportImage);
            
            // Text Modal Events
            document.getElementById('cancelTextBtn').addEventListener('click', () => textModal.classList.add('hidden'));
            document.getElementById('confirmTextBtn').addEventListener('click', addTextToCanvas);
            document.getElementById('boldBtn').addEventListener('click', toggleTextStyle('bold'));
            document.getElementById('italicBtn').addEventListener('click', toggleTextStyle('italic'));
            document.getElementById('underlineBtn').addEventListener('click', toggleTextStyle('underline'));
            
            // AI Modal Events
            document.getElementById('cancelAiBtn').addEventListener('click', () => aiModal.classList.add('hidden'));
            document.getElementById('confirmAiBtn').addEventListener('click', simulateAiBackgroundRemove);
            
            // Toolbar Events
            document.querySelectorAll('.tool-button').forEach(button => {
                button.addEventListener('click', () => selectTool(button.dataset.tool));
            });
            
            // Drag & Drop Events
            setupDragAndDrop();
            
            // Initialize quality value display
            updateQualityValue();
        }
        
        // Setup drag and drop functionality
        function setupDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight() {
                dropArea.classList.add('border-primary');
            }
            
            function unhighlight() {
                dropArea.classList.remove('border-primary');
            }
            
            dropArea.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    handleImageFile(files[0]);
                }
            }
        }
        
        // Handle file selection
        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleImageFile(e.target.files[0]);
            }
        }
        
        // Process the selected image file
        function handleImageFile(file) {
            if (!file.type.match('image.*')) {
                alert('請選擇圖片文件。');
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                
                img.onload = function() {
                    // 重置 canvas and history
                    resetCanvas();
                    
                    // Set canvas dimensions
                    const maxWidth = window.innerWidth * 0.7;
                    const maxHeight = window.innerHeight * 0.7;
                    let width = img.width;
                    let height = img.height;
                    
                    // 調整大小 if image is too large
                    if (width > maxWidth) {
                        height *= maxWidth / width;
                        width = maxWidth;
                    }
                    
                    if (height > maxHeight) {
                        width *= maxHeight / height;
                        height = maxHeight;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    // Draw image on canvas
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Store original image
                    originalImage = img;
                    currentImage = img;
                    
                    // Save initial state to history
                    saveToHistory();
                    
                    // Show canvas, hide drop area
                    dropArea.classList.add('hidden');
                    canvasContainer.classList.remove('hidden');
                    
                    // Enable save button
                    document.getElementById('saveImageBtn').disabled = false;
                    
                    // Automatically open crop panel after image upload
                    setTimeout(() => {
                        selectTool('crop');
                    }, 500);
                };
                
                img.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        }
        
        // Create a new blank image
        function newImage() {
            // Show prompt for image dimensions
            const width = prompt('請輸入圖片寬度:', '800');
            const height = prompt('請輸入圖片高度:', '600');
            
            if (width && height && !isNaN(width) && !isNaN(height)) {
                // 重置 canvas and history
                resetCanvas();
                
                // Set canvas dimensions
                canvas.width = parseInt(width);
                canvas.height = parseInt(height);
                
                // Fill with white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Save initial state to history
                saveToHistory();
                
                // Show canvas, hide drop area
                dropArea.classList.add('hidden');
                canvasContainer.classList.remove('hidden');
                
                // Enable save button
                document.getElementById('saveImageBtn').disabled = false;
            }
        }
        
        // 重置 canvas to initial state
        function resetCanvas() {
            textObjects = [];
            history = [];
            historyIndex = -1;
            currentTool = 'none';
            selectedTextIndex = -1;
            
            // 重置 tool buttons
            document.querySelectorAll('.tool-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Hide properties panel
            propertiesPanel.classList.add('hidden');
        }
        
        // Select a tool from the toolbar
        function selectTool(tool) {
            // Update active tool button
            document.querySelectorAll('.tool-button').forEach(button => {
                button.classList.toggle('active', button.dataset.tool === tool);
            });
            
            currentTool = tool;
            
            // Handle special tools
            switch (tool) {
                case 'text':
                    textModal.classList.remove('hidden');
                    break;
                case 'ai':
                    aiModal.classList.remove('hidden');
                    break;
                case 'undo':
                    undo();
                    break;
                case 'redo':
                    redo();
                    break;
                case 'reset':
                    resetToOriginal();
                    break;
                default:
                    showPropertiesPanel(tool);
                    break;
            }
        }
        
        // Show properties panel for selected tool
        function showPropertiesPanel(tool) {
            propertiesPanel.classList.remove('hidden');
            
            switch (tool) {
                case 'crop':
                    show裁剪Panel();
                    break;
                case 'resize':
                    show調整大小Panel();
                    break;
                case 'rotate-flip':
                    show旋轉Panel();
                    break;
                case 'adjust':
                    showAdjustPanel();
                    break;
                case 'filter':
                    showFilterPanel();
                    break;
                default:
                    propertiesPanel.classList.add('hidden');
                    break;
            }
        }
        
        // 裁剪 Panel
        function show裁剪Panel() {
            panelContent.innerHTML = `
                <div class="panel-section">
                    <h3 class="panel-title">裁剪圖片</h3>
                    <p class="text-sm text-white/70 mb-4">點擊並拖動圖片以選擇裁剪區域</p>
                    
                    <div class="mb-6">
                        <label class="block text-sm text-white/70 mb-3">寬高比</label>
                        <div class="grid grid-cols-3 gap-2">
                            <button class="aspect-btn active" data-ratio="free">自由</button>
                            <button class="aspect-btn" data-ratio="1:1">1:1</button>
                            <button class="aspect-btn" data-ratio="4:3">4:3</button>
                            <button class="aspect-btn" data-ratio="16:9">16:9</button>
                            <button class="aspect-btn" data-ratio="3:4">3:4</button>
                            <button class="aspect-btn" data-ratio="9:16">9:16</button>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <label class="block text-sm text-white/70 mb-3">形狀</label>
                        <div class="flex space-x-2">
                            <button id="rectangleBtn" class="flex-1 aspect-btn active" data-shape="rectangle">
                                <i class="fa fa-square-o mr-1"></i> 矩形
                            </button>
                            <button id="circleBtn" class="flex-1 aspect-btn" data-shape="circle">
                                <i class="fa fa-circle-o mr-1"></i> 圓形
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <label class="block text-sm text-white/70 mb-3">裁剪位置</label>
                        <div class="grid grid-cols-3 gap-2">
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('top-left')" title="左上角">
                                <i class="fa fa-arrow-up fa-rotate-45"></i>
                            </button>
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('top')" title="上">
                                <i class="fa fa-arrow-up"></i>
                            </button>
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('top-right')" title="右上角">
                                <i class="fa fa-arrow-up fa-rotate-315"></i>
                            </button>
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('left')" title="左">
                                <i class="fa fa-arrow-left"></i>
                            </button>
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('center')" title="中間">
                                <i class="fa fa-crosshairs"></i>
                            </button>
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('right')" title="右">
                                <i class="fa fa-arrow-right"></i>
                            </button>
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('bottom-left')" title="左下角">
                                <i class="fa fa-arrow-down fa-rotate-45"></i>
                            </button>
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('bottom')" title="下">
                                <i class="fa fa-arrow-down"></i>
                            </button>
                            <button class="btn btn-secondary w-full" onclick="move裁剪Area('bottom-right')" title="右下角">
                                <i class="fa fa-arrow-down fa-rotate-315"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="flex justify-between pt-4 border-t border-white/10">
                    <button id="cancel裁剪Btn" class="btn btn-secondary flex-1 mr-2">
                        <i class="fa fa-times mr-2"></i> 取消
                    </button>
                    <button id="apply裁剪Btn" class="btn btn-primary flex-1 ml-2">
                        <i class="fa fa-check mr-2"></i> 應用裁剪
                    </button>
                </div>
            `;
            
            // Add event listeners
            document.getElementById('apply裁剪Btn').addEventListener('click', apply裁剪);
            document.getElementById('cancel裁剪Btn').addEventListener('click', () => {
                currentTool = 'none';
                document.querySelectorAll('.tool-button').forEach(button => {
                    button.classList.remove('active');
                });
                propertiesPanel.classList.add('hidden');
                clear裁剪Selection();
            });
            
            // Add aspect ratio button listeners
            document.querySelectorAll('.aspect-btn[data-ratio]').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Update active button
                    document.querySelectorAll('.aspect-btn[data-ratio]').forEach(b => b.classList.remove('active', 'bg-primary/20', 'text-primary'));
                    btn.classList.add('active', 'bg-primary/20', 'text-primary');
                    
                    // Apply aspect ratio to current selection
                    applyAspectRatio(btn.dataset.ratio);
                });
            });
            
            // Add shape button listeners
            document.querySelectorAll('[data-shape]').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Update active button
                    document.querySelectorAll('[data-shape]').forEach(b => b.classList.remove('active', 'bg-primary/20', 'text-primary'));
                    btn.classList.add('active', 'bg-primary/20', 'text-primary');
                    
                    // Redraw selection with new shape
                    draw裁剪Selection();
                });
            });
            
            // Setup crop selection
            setup裁剪Selection();
        }
        
        // Setup crop selection on canvas
        function setup裁剪Selection() {
            canvas.style.cursor = 'crosshair';
            
            // Variables for crop selection dragging
            let isMovingSelection = false;
            let lastMousePos = { x: 0, y: 0 };
            let mouseOffset = { x: 0, y: 0 }; // Mouse offset within the selection
            
            // Check if mouse is inside crop selection
            function isMouseInsideSelection(x, y) {
                const minX = Math.min(cropStart.x, cropEnd.x);
                const maxX = Math.max(cropStart.x, cropEnd.x);
                const minY = Math.min(cropStart.y, cropEnd.y);
                const maxY = Math.max(cropStart.y, cropEnd.y);
                
                return x >= minX && x <= maxX && y >= minY && y <= maxY;
            }
            
            // Start crop selection or moving selection
            canvas.addEventListener('mousedown', (e) => {
                if (currentTool !== 'crop') return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                // Check if we have an existing selection
                const hasSelection = Math.abs(cropEnd.x - cropStart.x) > 5 && Math.abs(cropEnd.y - cropStart.y) > 5;
                
                if (hasSelection && isMouseInsideSelection(mouseX, mouseY)) {
                    // Start moving the selection
                    isMovingSelection = true;
                    lastMousePos = { x: mouseX, y: mouseY };
                    
                    // Calculate mouse offset within the selection
                    const selectionX = Math.min(cropStart.x, cropEnd.x);
                    const selectionY = Math.min(cropStart.y, cropEnd.y);
                    mouseOffset.x = mouseX - selectionX;
                    mouseOffset.y = mouseY - selectionY;
                    
                    canvas.style.cursor = 'move';
                } else {
                    // Start new selection
                    cropStart.x = mouseX;
                    cropStart.y = mouseY;
                    cropEnd.x = mouseX;
                    cropEnd.y = mouseY;
                    isDragging = true;
                    canvas.style.cursor = 'crosshair';
                }
            });
            
            // Update crop selection or move selection
            canvas.addEventListener('mousemove', (e) => {
                if (currentTool !== 'crop') return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                if (isMovingSelection) {
                    // Get current selection dimensions
                    const currentX = Math.min(cropStart.x, cropEnd.x);
                    const currentY = Math.min(cropStart.y, cropEnd.y);
                    const currentWidth = Math.abs(cropEnd.x - cropStart.x);
                    const currentHeight = Math.abs(cropEnd.y - cropStart.y);
                    
                    // Calculate new position with mouse as center
                    const newX = mouseX - mouseOffset.x;
                    const newY = mouseY - mouseOffset.y;
                    
                    // Calculate new cropStart and cropEnd based on new position
                    if (cropStart.x < cropEnd.x && cropStart.y < cropEnd.y) {
                        // Normal case: cropStart is top-left, cropEnd is bottom-right
                        cropStart.x = newX;
                        cropStart.y = newY;
                        cropEnd.x = newX + currentWidth;
                        cropEnd.y = newY + currentHeight;
                    } else if (cropStart.x > cropEnd.x && cropStart.y < cropEnd.y) {
                        // cropStart is top-right, cropEnd is bottom-left
                        cropStart.x = newX + currentWidth;
                        cropStart.y = newY;
                        cropEnd.x = newX;
                        cropEnd.y = newY + currentHeight;
                    } else if (cropStart.x < cropEnd.x && cropStart.y > cropEnd.y) {
                        // cropStart is bottom-left, cropEnd is top-right
                        cropStart.x = newX;
                        cropStart.y = newY + currentHeight;
                        cropEnd.x = newX + currentWidth;
                        cropEnd.y = newY;
                    } else {
                        // cropStart is bottom-right, cropEnd is top-left
                        cropStart.x = newX + currentWidth;
                        cropStart.y = newY + currentHeight;
                        cropEnd.x = newX;
                        cropEnd.y = newY;
                    }
                    
                    // Constrain to canvas bounds
                    const minX = Math.min(cropStart.x, cropEnd.x);
                    const maxX = Math.max(cropStart.x, cropEnd.x);
                    const minY = Math.min(cropStart.y, cropEnd.y);
                    const maxY = Math.max(cropStart.y, cropEnd.y);
                    
                    // Apply constraints while maintaining the offset
                    // First, calculate the current selection bounds
                    const currentX2 = Math.min(cropStart.x, cropEnd.x);
                    const currentY2 = Math.min(cropStart.y, cropEnd.y);
                    const currentWidth2 = Math.abs(cropEnd.x - cropStart.x);
                    const currentHeight2 = Math.abs(cropEnd.y - cropStart.y);
                    
                    // Calculate new position without constraints
                    let targetX = mouseX - mouseOffset.x;
                    let targetY = mouseY - mouseOffset.y;
                    
                    // Apply boundary constraints
                    // Left boundary
                    if (targetX < 0) {
                        targetX = 0;
                        // Update mouse offset to maintain relative position
                        mouseOffset.x = mouseX - targetX;
                    }
                    
                    // Right boundary
                    if (targetX + currentWidth2 > canvas.width) {
                        targetX = canvas.width - currentWidth2;
                        // Update mouse offset to maintain relative position
                        mouseOffset.x = mouseX - targetX;
                    }
                    
                    // Top boundary
                    if (targetY < 0) {
                        targetY = 0;
                        // Update mouse offset to maintain relative position
                        mouseOffset.y = mouseY - targetY;
                    }
                    
                    // Bottom boundary
                    if (targetY + currentHeight2 > canvas.height) {
                        targetY = canvas.height - currentHeight2;
                        // Update mouse offset to maintain relative position
                        mouseOffset.y = mouseY - targetY;
                    }
                    
                    // Calculate the offset needed to stay within bounds
                    const xOffset = targetX - currentX2;
                    const yOffset = targetY - currentY2;
                    
                    // Apply offsets if needed
                    if (xOffset !== 0 || yOffset !== 0) {
                        // Update cropStart and cropEnd based on the new target position
                        if (cropStart.x < cropEnd.x && cropStart.y < cropEnd.y) {
                            // Normal case: cropStart is top-left, cropEnd is bottom-right
                            cropStart.x = targetX;
                            cropStart.y = targetY;
                            cropEnd.x = targetX + currentWidth2;
                            cropEnd.y = targetY + currentHeight2;
                        } else if (cropStart.x > cropEnd.x && cropStart.y < cropEnd.y) {
                            // cropStart is top-right, cropEnd is bottom-left
                            cropStart.x = targetX + currentWidth2;
                            cropStart.y = targetY;
                            cropEnd.x = targetX;
                            cropEnd.y = targetY + currentHeight2;
                        } else if (cropStart.x < cropEnd.x && cropStart.y > cropEnd.y) {
                            // cropStart is bottom-left, cropEnd is top-right
                            cropStart.x = targetX;
                            cropStart.y = targetY + currentHeight2;
                            cropEnd.x = targetX + currentWidth2;
                            cropEnd.y = targetY;
                        } else {
                            // cropStart is bottom-right, cropEnd is top-left
                            cropStart.x = targetX + currentWidth2;
                            cropStart.y = targetY + currentHeight2;
                            cropEnd.x = targetX;
                            cropEnd.y = targetY;
                        }
                        
                        // Update mouse offset to maintain the same relative position
                        mouseOffset.x += xOffset;
                        mouseOffset.y += yOffset;
                    }
                    
                    // Update last mouse position
                    lastMousePos = { x: mouseX, y: mouseY };
                    
                    // Redraw selection
                    draw裁剪Selection();
                } else if (isDragging) {
                    // Update crop selection with aspect ratio constraint
                    let newX = mouseX;
                    let newY = mouseY;
                    
                    // Get selected aspect ratio from active button
                    const activeAspectBtn = document.querySelector('.aspect-btn.active');
                    const aspectRatio = activeAspectBtn ? activeAspectBtn.dataset.ratio : 'free';
                    
                    // Apply aspect ratio constraint if not free
                    if (aspectRatio !== 'free') {
                        const [widthRatio, heightRatio] = aspectRatio.split(':').map(Number);
                        const ratio = widthRatio / heightRatio;
                        
                        // Calculate new dimensions based on aspect ratio
                        const width = Math.abs(newX - cropStart.x);
                        const height = width / ratio;
                        
                        // Determine if we're dragging horizontally or vertically
                        const deltaX = Math.abs(newX - cropStart.x);
                        const deltaY = Math.abs(newY - cropStart.y);
                        
                        if (deltaX > deltaY) {
                            // Horizontal drag - adjust Y
                            newY = cropStart.y + (newX > cropStart.x ? height : -height);
                        } else {
                            // Vertical drag - adjust X
                            newX = cropStart.x + (newY > cropStart.y ? height * ratio : -height * ratio);
                        }
                    }
                    
                    // Constrain to canvas bounds
                    newX = Math.max(0, Math.min(canvas.width, newX));
                    newY = Math.max(0, Math.min(canvas.height, newY));
                    
                    cropEnd.x = newX;
                    cropEnd.y = newY;
                    
                    draw裁剪Selection();
                } else {
                    // Update cursor based on mouse position
                    const hasSelection = Math.abs(cropEnd.x - cropStart.x) > 5 && Math.abs(cropEnd.y - cropStart.y) > 5;
                    if (hasSelection && isMouseInsideSelection(mouseX, mouseY)) {
                        canvas.style.cursor = 'move';
                    } else {
                        canvas.style.cursor = 'crosshair';
                    }
                }
            });
            
            // End crop selection or moving selection
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                isMovingSelection = false;
                
                // Update cursor
                const hasSelection = Math.abs(cropEnd.x - cropStart.x) > 5 && Math.abs(cropEnd.y - cropStart.y) > 5;
                if (hasSelection) {
                    canvas.style.cursor = 'move';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                isMovingSelection = false;
            });
        }
        

        
        // Draw crop selection overlay
        function draw裁剪Selection() {
            // Clear previous overlay
            canvasOverlay.innerHTML = '';
            
            // Calculate selection dimensions
            const x = Math.min(cropStart.x, cropEnd.x);
            const y = Math.min(cropStart.y, cropEnd.y);
            const width = Math.abs(cropEnd.x - cropStart.x);
            const height = Math.abs(cropEnd.y - cropStart.y);
            
            // Get selected shape
            const activeShapeBtn = document.querySelector('[data-shape].active');
            const shape = activeShapeBtn ? activeShapeBtn.dataset.shape : 'rectangle';
            
            if (shape === 'circle') {
                // Create circular selection
                const radius = Math.min(width, height) / 2;
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                
                // Create SVG overlay
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.style.position = 'absolute';
                svg.style.left = '0';
                svg.style.top = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                
                // Create mask
                const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
                mask.id = 'cropMask';
                
                // Create background rectangle
                const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bgRect.setAttribute('x', '0');
                bgRect.setAttribute('y', '0');
                bgRect.setAttribute('width', '100%');
                bgRect.setAttribute('height', '100%');
                bgRect.setAttribute('fill', 'black');
                
                // Create circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', centerY);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', 'white');
                
                // Assemble mask
                mask.appendChild(bgRect);
                mask.appendChild(circle);
                svg.appendChild(mask);
                
                // Create overlay rectangle with mask
                const overlayRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                overlayRect.setAttribute('x', '0');
                overlayRect.setAttribute('y', '0');
                overlayRect.setAttribute('width', '100%');
                overlayRect.setAttribute('height', '100%');
                overlayRect.setAttribute('fill', 'rgba(0, 0, 0, 0.3)');
                overlayRect.setAttribute('mask', 'url(#cropMask)');
                
                svg.appendChild(overlayRect);
                
                // Create circle border
                const borderCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                borderCircle.setAttribute('cx', centerX);
                borderCircle.setAttribute('cy', centerY);
                borderCircle.setAttribute('r', radius);
                borderCircle.setAttribute('fill', 'none');
                borderCircle.setAttribute('stroke', 'white');
                borderCircle.setAttribute('stroke-width', '2');
                borderCircle.setAttribute('stroke-dasharray', '5,5');
                
                svg.appendChild(borderCircle);
                
                canvasOverlay.appendChild(svg);
            } else {
                // Create rectangular selection
                const overlay = document.createElement('div');
                overlay.style.position = 'absolute';
                overlay.style.left = `${x}px`;
                overlay.style.top = `${y}px`;
                overlay.style.width = `${width}px`;
                overlay.style.height = `${height}px`;
                overlay.style.border = '2px dashed white';
                overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
                
                canvasOverlay.appendChild(overlay);
            }
        }
        
        // Clear crop selection
        function clear裁剪Selection() {
            canvas.style.cursor = 'default';
            canvasOverlay.innerHTML = '';
            
            canvas.removeEventListener('mousedown', start裁剪Selection);
            canvas.removeEventListener('mousemove', update裁剪Selection);
            canvas.removeEventListener('mouseup', end裁剪Selection);
            canvas.removeEventListener('mouseleave', end裁剪Selection);
        }
        
        // Move crop area to specific position
        function move裁剪Area(position) {
            if (!currentImage) return;
            
            // Check if we have a valid selection
            const hasSelection = Math.abs(cropEnd.x - cropStart.x) > 5 && Math.abs(cropEnd.y - cropStart.y) > 5;
            
            if (!hasSelection) return;
            
            const x = Math.min(cropStart.x, cropEnd.x);
            const y = Math.min(cropStart.y, cropEnd.y);
            const width = Math.abs(cropEnd.x - cropStart.x);
            const height = Math.abs(cropEnd.y - cropStart.y);
            
            // Calculate new position based on the selected preset
            switch (position) {
                case 'top-left':
                    cropStart.x = 0;
                    cropStart.y = 0;
                    cropEnd.x = width;
                    cropEnd.y = height;
                    break;
                case 'top':
                    cropStart.x = (canvas.width - width) / 2;
                    cropStart.y = 0;
                    cropEnd.x = (canvas.width + width) / 2;
                    cropEnd.y = height;
                    break;
                case 'top-right':
                    cropStart.x = canvas.width - width;
                    cropStart.y = 0;
                    cropEnd.x = canvas.width;
                    cropEnd.y = height;
                    break;
                case 'left':
                    cropStart.x = 0;
                    cropStart.y = (canvas.height - height) / 2;
                    cropEnd.x = width;
                    cropEnd.y = (canvas.height + height) / 2;
                    break;
                case 'center':
                    cropStart.x = (canvas.width - width) / 2;
                    cropStart.y = (canvas.height - height) / 2;
                    cropEnd.x = (canvas.width + width) / 2;
                    cropEnd.y = (canvas.height + height) / 2;
                    break;
                case 'right':
                    cropStart.x = canvas.width - width;
                    cropStart.y = (canvas.height - height) / 2;
                    cropEnd.x = canvas.width;
                    cropEnd.y = (canvas.height + height) / 2;
                    break;
                case 'bottom-left':
                    cropStart.x = 0;
                    cropStart.y = canvas.height - height;
                    cropEnd.x = width;
                    cropEnd.y = canvas.height;
                    break;
                case 'bottom':
                    cropStart.x = (canvas.width - width) / 2;
                    cropStart.y = canvas.height - height;
                    cropEnd.x = (canvas.width + width) / 2;
                    cropEnd.y = canvas.height;
                    break;
                case 'bottom-right':
                    cropStart.x = canvas.width - width;
                    cropStart.y = canvas.height - height;
                    cropEnd.x = canvas.width;
                    cropEnd.y = canvas.height;
                    break;
                default:
                    return;
            }
            
            draw裁剪Selection();
        }
        
        // Apply aspect ratio to current crop selection
        function applyAspectRatio(aspectRatio) {
            // Check if we have a valid selection
            const hasSelection = Math.abs(cropEnd.x - cropStart.x) > 5 && Math.abs(cropEnd.y - cropStart.y) > 5;
            
            if (!hasSelection) {
                // If no selection, create a new one with the aspect ratio
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const defaultSize = Math.min(canvas.width, canvas.height) * 0.5;
                
                if (aspectRatio === 'free') {
                    // Create a square selection
                    cropStart.x = centerX - defaultSize / 2;
                    cropStart.y = centerY - defaultSize / 2;
                    cropEnd.x = centerX + defaultSize / 2;
                    cropEnd.y = centerY + defaultSize / 2;
                } else {
                    const [widthRatio, heightRatio] = aspectRatio.split(':').map(Number);
                    const ratio = widthRatio / heightRatio;
                    
                    // Calculate dimensions based on aspect ratio
                    let width, height;
                    
                    if (ratio > 1) {
                        // Landscape orientation
                        width = defaultSize;
                        height = defaultSize / ratio;
                    } else {
                        // Portrait orientation
                        height = defaultSize;
                        width = defaultSize * ratio;
                    }
                    
                    // Create selection with aspect ratio
                    cropStart.x = centerX - width / 2;
                    cropStart.y = centerY - height / 2;
                    cropEnd.x = centerX + width / 2;
                    cropEnd.y = centerY + height / 2;
                }
            } else {
                // If we have a selection, adjust it to the new aspect ratio
                const x = Math.min(cropStart.x, cropEnd.x);
                const y = Math.min(cropStart.y, cropEnd.y);
                const width = Math.abs(cropEnd.x - cropStart.x);
                const height = Math.abs(cropEnd.y - cropStart.y);
                
                // Calculate center of current selection
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                
                if (aspectRatio === 'free') {
                    // Keep current size for free aspect ratio
                    return;
                } else {
                    const [widthRatio, heightRatio] = aspectRatio.split(':').map(Number);
                    const ratio = widthRatio / heightRatio;
                    
                    // Calculate new dimensions based on aspect ratio
                    let newWidth, newHeight;
                    
                    // Use the larger dimension to maintain as much of the image as possible
                    if (width / height > ratio) {
                        // Current selection is wider than target ratio
                        newHeight = height;
                        newWidth = height * ratio;
                    } else {
                        // Current selection is taller than target ratio
                        newWidth = width;
                        newHeight = width / ratio;
                    }
                    
                    // Update selection with new dimensions, keeping the center
                    cropStart.x = centerX - newWidth / 2;
                    cropStart.y = centerY - newHeight / 2;
                    cropEnd.x = centerX + newWidth / 2;
                    cropEnd.y = centerY + newHeight / 2;
                    
                    // Constrain to canvas bounds
                    if (cropStart.x < 0) {
                        cropEnd.x -= cropStart.x;
                        cropStart.x = 0;
                    }
                    
                    if (cropEnd.x > canvas.width) {
                        cropStart.x -= (cropEnd.x - canvas.width);
                        cropEnd.x = canvas.width;
                    }
                    
                    if (cropStart.y < 0) {
                        cropEnd.y -= cropStart.y;
                        cropStart.y = 0;
                    }
                    
                    if (cropEnd.y > canvas.height) {
                        cropStart.y -= (cropEnd.y - canvas.height);
                        cropEnd.y = canvas.height;
                    }
                }
            }
            
            // Redraw crop selection
            draw裁剪Selection();
        }
        
        // Apply crop
        function apply裁剪() {
            // Calculate crop dimensions
            const x = Math.min(cropStart.x, cropEnd.x);
            const y = Math.min(cropStart.y, cropEnd.y);
            const width = Math.abs(cropEnd.x - cropStart.x);
            const height = Math.abs(cropEnd.y - cropStart.y);
            
            // Validate crop dimensions
            if (width < 10 || height < 10) {
                alert('Please select a larger crop area.');
                return;
            }
            
            // Get selected shape
            const activeShapeBtn = document.querySelector('[data-shape].active');
            const shape = activeShapeBtn ? activeShapeBtn.dataset.shape : 'rectangle';
            
            if (shape === 'circle') {
                // Create circular crop
                const radius = Math.min(width, height) / 2;
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const diameter = radius * 2;
                
                // Create temporary canvas for circular crop
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = diameter;
                tempCanvas.height = diameter;
                
                // Draw image centered on temporary canvas
                tempCtx.drawImage(canvas, centerX - radius, centerY - radius, diameter, diameter, 0, 0, diameter, diameter);
                
                // Create new canvas with circular dimensions
                canvas.width = diameter;
                canvas.height = diameter;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Create circular clipping path
                ctx.beginPath();
                ctx.arc(radius, radius, radius, 0, Math.PI * 2);
                ctx.clip();
                
                // Draw image onto circular clipping path
                ctx.drawImage(tempCanvas, 0, 0);
                
                // Reset clipping path
                ctx.restore();
            } else {
                // Create rectangular crop
                // Get image data from crop area
                const imageData = ctx.getImageData(x, y, width, height);
                
                // Create new canvas with crop dimensions
                canvas.width = width;
                canvas.height = height;
                
                // Draw cropped image
                ctx.putImageData(imageData, 0, 0);
            }
            
            // Save to history
            saveToHistory();
            
            // Clear crop selection
            clear裁剪Selection();
            
            // Hide properties panel
            propertiesPanel.classList.add('hidden');
        }
        
        // 調整大小 Panel
        function show調整大小Panel() {
            // Get current dimensions
            const currentWidth = canvas.width;
            const currentHeight = canvas.height;
            
            panelContent.innerHTML = `
                <h3 class="text-lg font-bold mb-4">調整大小</h3>
                <div class="mb-4">
                    <label class="block text-sm text-white/70 mb-1">寬度 (px)</label>
                    <input type="number" id="resizeWidth" class="w-full bg-white/10 border border-white/20 rounded-md px-3 py-2" value="${currentWidth}">
                </div>
                <div class="mb-4">
                    <label class="block text-sm text-white/70 mb-1">高度 (px)</label>
                    <input type="number" id="resizeHeight" class="w-full bg-white/10 border border-white/20 rounded-md px-3 py-2" value="${currentHeight}">
                </div>
                <div class="flex items-center mb-4">
                    <input type="checkbox" id="maintainAspectRatio" class="mr-2" checked>
                    <label for="maintainAspectRatio" class="text-sm text-white/70">保持寬高比</label>
                </div>
                <div class="flex space-x-2">
                    <button id="apply調整大小Btn" class="flex-1 px-3 py-2 bg-primary hover:bg-secondary rounded-md transition-colors">
                        應用
                    </button>
                    <button id="cancel調整大小Btn" class="flex-1 px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors">
                        取消
                    </button>
                </div>
            `;
            
            // Add event listeners
            const widthInput = document.getElementById('resizeWidth');
            const heightInput = document.getElementById('resizeHeight');
            const maintainAspectRatio = document.getElementById('maintainAspectRatio');
            
            let aspectRatio = currentWidth / currentHeight;
            let isUpdating = false;
            
            widthInput.addEventListener('input', () => {
                if (maintainAspectRatio.checked && !isUpdating) {
                    isUpdating = true;
                    heightInput.value = Math.round(widthInput.value / aspectRatio);
                    isUpdating = false;
                }
            });
            
            heightInput.addEventListener('input', () => {
                if (maintainAspectRatio.checked && !isUpdating) {
                    isUpdating = true;
                    widthInput.value = Math.round(heightInput.value * aspectRatio);
                    isUpdating = false;
                }
            });
            
            document.getElementById('apply調整大小Btn').addEventListener('click', () => {
                const newWidth = parseInt(widthInput.value);
                const newHeight = parseInt(heightInput.value);
                
                if (newWidth > 0 && newHeight > 0) {
                    resizeImage(newWidth, newHeight);
                } else {
                    alert('請輸入有效的尺寸。');
                }
            });
            
            document.getElementById('cancel調整大小Btn').addEventListener('click', () => {
                propertiesPanel.classList.add('hidden');
            });
        }
        
        // 調整大小 image
        function resizeImage(width, height) {
            // Show loading overlay
            loadingOverlay.classList.remove('hidden');
            loadingText.textContent = '調整圖片大小中...';
            
            setTimeout(() => {
                // Create temporary canvas
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Set temporary canvas dimensions
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                
                // Copy current image to temporary canvas
                tempCtx.drawImage(canvas, 0, 0);
                
                // Update main canvas dimensions
                canvas.width = width;
                canvas.height = height;
                
                // Draw resized image
                ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, width, height);
                
                // Save to history
                saveToHistory();
                
                // Hide loading overlay
                loadingOverlay.classList.add('hidden');
                
                // Hide properties panel
                propertiesPanel.classList.add('hidden');
            }, 300);
        }
        
        // 旋轉 Panel
        function show旋轉Panel() {
            panelContent.innerHTML = `
                <h3 class="text-lg font-bold mb-4">旋轉</h3>
                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button id="rotateLeftBtn" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors flex items-center justify-center">
                        <i class="fa fa-rotate-left mr-2"></i> 90° 左
                    </button>
                    <button id="rotateRightBtn" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors flex items-center justify-center">
                        <i class="fa fa-rotate-right mr-2"></i> 90° 右
                    </button>
                    <button id="rotate180Btn" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors flex items-center justify-center">
                        <i class="fa fa-refresh mr-2"></i> 180°
                    </button>
                    <button id="rotateCustomBtn" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors flex items-center justify-center">
                        <i class="fa fa-sliders mr-2"></i> 自訂
                    </button>
                </div>
                <div id="custom旋轉Container" class="hidden mb-4">
                    <label class="block text-sm text-white/70 mb-1">旋轉角度</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="rotateAngle" min="0" max="359" value="0" class="flex-1">
                        <span id="angleValue" class="text-sm w-10">0°</span>
                    </div>
                </div>
                <button id="applyRotationBtn" class="w-full px-3 py-2 bg-primary hover:bg-secondary rounded-md transition-colors hidden">
                    應用
                </button>
            `;
            
            // Add event listeners
            document.getElementById('rotateLeftBtn').addEventListener('click', () => rotateImage(-90));
            document.getElementById('rotateRightBtn').addEventListener('click', () => rotateImage(90));
            document.getElementById('rotate180Btn').addEventListener('click', () => rotateImage(180));
            
            const rotateCustomBtn = document.getElementById('rotateCustomBtn');
            const custom旋轉Container = document.getElementById('custom旋轉Container');
            const applyRotationBtn = document.getElementById('applyRotationBtn');
            const rotateAngle = document.getElementById('rotateAngle');
            const angleValue = document.getElementById('angleValue');
            
            rotateCustomBtn.addEventListener('click', () => {
                custom旋轉Container.classList.toggle('hidden');
                applyRotationBtn.classList.toggle('hidden');
            });
            
            rotateAngle.addEventListener('input', () => {
                angleValue.textContent = `${rotateAngle.value}°`;
            });
            
            applyRotationBtn.addEventListener('click', () => {
                rotateImage(parseInt(rotateAngle.value));
            });
        }
        
        // 旋轉 image
        function rotateImage(angle) {
            // Show loading overlay
            loadingOverlay.classList.remove('hidden');
            loadingText.textContent = '旋轉圖片中...';
            
            setTimeout(() => {
                // Convert angle to radians
                const radians = (angle * Math.PI) / 180;
                
                // Calculate new dimensions
                const newWidth = Math.abs(canvas.width * Math.cos(radians)) + Math.abs(canvas.height * Math.sin(radians));
                const newHeight = Math.abs(canvas.width * Math.sin(radians)) + Math.abs(canvas.height * Math.cos(radians));
                
                // Create temporary canvas
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Set temporary canvas dimensions
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                
                // Copy current image to temporary canvas
                tempCtx.drawImage(canvas, 0, 0);
                
                // Update main canvas dimensions
                canvas.width = newWidth;
                canvas.height = newHeight;
                
                // Translate to center, rotate, and draw
                ctx.translate(newWidth / 2, newHeight / 2);
                ctx.rotate(radians);
                ctx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
                
                // 重置 transformation
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Save to history
                saveToHistory();
                
                // Hide loading overlay
                loadingOverlay.classList.add('hidden');
                
                // Hide properties panel
                propertiesPanel.classList.add('hidden');
            }, 300);
        }
        

        
        // 翻轉 image
        function flipImage(horizontal, vertical) {
            // Show loading overlay
            loadingOverlay.classList.remove('hidden');
            loadingText.textContent = '翻轉ping image...';
            
            setTimeout(() => {
                // Create temporary canvas
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Set temporary canvas dimensions
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                
                // Copy current image to temporary canvas
                tempCtx.drawImage(canvas, 0, 0);
                
                // Apply flip transformation
                ctx.save();
                
                if (horizontal) {
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                }
                
                if (vertical) {
                    ctx.translate(0, canvas.height);
                    ctx.scale(1, -1);
                }
                
                // Draw flipped image
                ctx.drawImage(tempCanvas, 0, 0);
                
                // 重置 transformation
                ctx.restore();
                
                // Save to history
                saveToHistory();
                
                // Hide loading overlay
                loadingOverlay.classList.add('hidden');
                
                // Hide properties panel
                propertiesPanel.classList.add('hidden');
            }, 300);
        }
        
        // Adjust Panel
        function showAdjustPanel() {
            panelContent.innerHTML = `
                <h3 class="text-lg font-bold mb-4">調整</h3>
                <div class="mb-4">
                    <label class="block text-sm text-white/70 mb-1">亮度</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="brightnessSlider" min="-100" max="100" value="0" class="flex-1">
                        <span id="brightnessValue" class="text-sm w-8">0</span>
                    </div>
                </div>
                <div class="mb-4">
                    <label class="block text-sm text-white/70 mb-1">對比度</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="contrastSlider" min="-100" max="100" value="0" class="flex-1">
                        <span id="contrastValue" class="text-sm w-8">0</span>
                    </div>
                </div>
                <div class="mb-4">
                    <label class="block text-sm text-white/70 mb-1">飽和度</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="saturationSlider" min="-100" max="100" value="0" class="flex-1">
                        <span id="saturationValue" class="text-sm w-8">0</span>
                    </div>
                </div>
                <div class="mb-4">
                    <label class="block text-sm text-white/70 mb-1">模糊</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="blurSlider" min="0" max="20" value="0" class="flex-1">
                        <span id="blurValue" class="text-sm w-8">0</span>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <button id="resetAdjustBtn" class="flex-1 px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors">
                        重置
                    </button>
                    <button id="applyAdjustBtn" class="flex-1 px-3 py-2 bg-primary hover:bg-secondary rounded-md transition-colors">
                        應用
                    </button>
                </div>
            `;
            
            // Add event listeners
            const brightnessSlider = document.getElementById('brightnessSlider');
            const contrastSlider = document.getElementById('contrastSlider');
            const saturationSlider = document.getElementById('saturationSlider');
            const blurSlider = document.getElementById('blurSlider');
            
            const brightnessValue = document.getElementById('brightnessValue');
            const contrastValue = document.getElementById('contrastValue');
            const saturationValue = document.getElementById('saturationValue');
            const blurValue = document.getElementById('blurValue');
            
            // Update display values
            brightnessSlider.addEventListener('input', () => {
                brightnessValue.textContent = brightnessSlider.value;
                preview調整();
            });
            
            contrastSlider.addEventListener('input', () => {
                contrastValue.textContent = contrastSlider.value;
                preview調整();
            });
            
            saturationSlider.addEventListener('input', () => {
                saturationValue.textContent = saturationSlider.value;
                preview調整();
            });
            
            blurSlider.addEventListener('input', () => {
                blurValue.textContent = blurSlider.value;
                preview調整();
            });
            
            // 重置 button
            document.getElementById('resetAdjustBtn').addEventListener('click', () => {
                brightnessSlider.value = 0;
                contrastSlider.value = 0;
                saturationSlider.value = 0;
                blurSlider.value = 0;
                
                brightnessValue.textContent = '0';
                contrastValue.textContent = '0';
                saturationValue.textContent = '0';
                blurValue.textContent = '0';
                
                preview調整();
            });
            
            // Apply button
            document.getElementById('applyAdjustBtn').addEventListener('click', () => {
                apply調整();
                propertiesPanel.classList.add('hidden');
            });
            
            // Initial preview
            preview調整();
        }
        
        // Preview adjustments in real-time
        function preview調整() {
            // Get current values
            const brightness = parseInt(document.getElementById('brightnessSlider').value);
            const contrast = parseInt(document.getElementById('contrastSlider').value);
            const saturation = parseInt(document.getElementById('saturationSlider').value);
            const blur = parseInt(document.getElementById('blurSlider').value);
            
            // Create temporary canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Set temporary canvas dimensions
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Copy current image to temporary canvas
            tempCtx.drawImage(canvas, 0, 0);
            
            // Apply filters
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // Apply brightness, contrast, and saturation
            for (let i = 0; i < data.length; i += 4) {
                // Convert RGB to HSL
                let [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
                
                // Adjust saturation
                s = Math.max(0, Math.min(1, s * (1 + saturation / 100)));
                
                // Adjust lightness (brightness)
                l = Math.max(0, Math.min(1, l + brightness / 200));
                
                // Adjust contrast
                if (contrast > 0) {
                    l = (l - 0.5) * (1 - contrast / 100) + 0.5;
                } else {
                    l = (l - 0.5) * (1 + contrast / 100) + 0.5;
                }
                
                // Convert HSL back to RGB
                const [r, g, b] = hslToRgb(h, s, l);
                
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
            
            // Apply blur (simplified version)
            if (blur > 0) {
                applyBlur(imageData, blur);
            }
            
            // Draw adjusted image
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Apply adjustments and save to history
        function apply調整() {
            // Save to history
            saveToHistory();
        }
        
        // Filter Panel
        function showFilterPanel() {
            // Create filter previews
            let filterHTML = `
                <h3 class="text-lg font-bold mb-4">濾鏡</h3>
                <div class="grid grid-cols-4 gap-2 mb-4">
            `;
            
            filterPresets.forEach((filter, index) => {
                filterHTML += `
                    <div class="filter-preview ${index === 0 ? 'active' : ''}" data-filter="${index}">
                        <img src="${canvas.toDataURL()}" class="w-full h-full object-cover" id="filterPreview${index}" onload="applyFilterToImage(this, filterPresets[${index}])">
                    </div>
                `;
            });
            
            filterHTML += `
                </div>
                <div class="flex space-x-2">
                    <button id="resetFilterBtn" class="flex-1 px-3 py-2 bg-white/10 hover:bg-white/20 rounded-md transition-colors">
                        重置
                    </button>
                    <button id="applyFilterBtn" class="flex-1 px-3 py-2 bg-primary hover:bg-secondary rounded-md transition-colors">
                        應用
                    </button>
                </div>
            `;
            
            panelContent.innerHTML = filterHTML;
            
            // Add event listeners
            document.querySelectorAll('.filter-preview').forEach(preview => {
                preview.addEventListener('click', () => {
                    // Remove active class from all previews
                    document.querySelectorAll('.filter-preview').forEach(p => p.classList.remove('active'));
                    
                    // Add active class to clicked preview
                    preview.classList.add('active');
                    
                    // Apply filter to main canvas (preview mode)
                    const filterIndex = parseInt(preview.dataset.filter);
                    applyFilter(filterPresets[filterIndex], true);
                });
            });
            
            // Add reset button event listener
            document.getElementById('resetFilterBtn').addEventListener('click', () => {
                // Reset to normal filter
                document.querySelectorAll('.filter-preview').forEach(p => p.classList.remove('active'));
                document.querySelector('.filter-preview[data-filter="0"]').classList.add('active');
                
                // Reset to original image by redrawing from current state
                // This ensures we don't accumulate filter effects
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
                
                // Apply normal filter (which has no effect) to ensure consistency
                applyFilter(filterPresets[0], true);
            });
            
            // Add apply button event listener
            document.getElementById('applyFilterBtn').addEventListener('click', () => {
                // Get active filter
                const activePreview = document.querySelector('.filter-preview.active');
                if (activePreview) {
                    const filterIndex = parseInt(activePreview.dataset.filter);
                    // Apply filter and save to history
                    applyFilter(filterPresets[filterIndex], false);
                    saveToHistory();
                    
                    // Hide properties panel
                    propertiesPanel.classList.add('hidden');
                }
            });
        }
        
        // Apply filter to preview image
        function applyFilterToImage(imgElement, filter) {
            // 检查是否已经处理过这个滤镜，避免重复处理
            if (imgElement.dataset.processedFilter === JSON.stringify(filter)) {
                return;
            }
            
            const tempImg = new Image();
            tempImg.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = 100;
                canvas.height = 100;
                
                // 绘制图像到临时画布
                ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Apply filter
                for (let i = 0; i < data.length; i += 4) {
                    // Convert RGB to HSL
                    let [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    
                    // Apply filter values
                    if (filter.values.brightness !== undefined) {
                        l = Math.max(0, Math.min(1, l + filter.values.brightness / 200));
                    }
                    
                    if (filter.values.contrast !== undefined) {
                        if (filter.values.contrast > 0) {
                            l = (l - 0.5) * (1 - filter.values.contrast / 100) + 0.5;
                        } else {
                            l = (l - 0.5) * (1 + filter.values.contrast / 100) + 0.5;
                        }
                    }
                    
                    if (filter.values.saturation !== undefined) {
                        s = Math.max(0, Math.min(1, s * (1 + filter.values.saturation / 100)));
                    }
                    
                    if (filter.values.grayscale !== undefined) {
                        s = Math.max(0, s * (1 - filter.values.grayscale / 100));
                    }
                    
                    if (filter.values.sepia !== undefined && filter.values.sepia > 0) {
                        // Apply sepia tone
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        data[i] = Math.min(255, (r * (1 - 0.607 * filter.values.sepia / 100)) + (g * 0.769 * filter.values.sepia / 100) + (b * 0.189 * filter.values.sepia / 100));
                        data[i + 1] = Math.min(255, (r * 0.349 * filter.values.sepia / 100) + (g * (1 - 0.314 * filter.values.sepia / 100)) + (b * 0.168 * filter.values.sepia / 100));
                        data[i + 2] = Math.min(255, (r * 0.272 * filter.values.sepia / 100) + (g * 0.534 * filter.values.sepia / 100) + (b * (1 - 0.869 * filter.values.sepia / 100)));
                        
                        continue; // Skip HSL conversion back
                    }
                    
                    if (filter.values.hue !== undefined) {
                        h = (h + filter.values.hue / 360) % 1;
                    }
                    
                    // Convert HSL back to RGB
                    const [r, g, b] = hslToRgb(h, s, l);
                    
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                }
                
                // Apply blur if needed
                if (filter.values.blur !== undefined && filter.values.blur > 0) {
                    applyBlur(imageData, filter.values.blur);
                }
                
                // Draw filtered image
                ctx.putImageData(imageData, 0, 0);
                
                // 标记此滤镜已处理
                imgElement.dataset.processedFilter = JSON.stringify(filter);
                
                // Update preview image with filtered result
                imgElement.src = canvas.toDataURL();
            };
            
            // 设置临时图像的源为原始图像数据
            tempImg.src = imgElement.dataset.originalSrc || imgElement.src;
            
            // 保存原始图像数据，以便后续处理
            if (!imgElement.dataset.originalSrc) {
                imgElement.dataset.originalSrc = imgElement.src;
            }
        }
        
        // Apply filter to main canvas
        function applyFilter(filter, previewMode = false) {
            // Create temporary canvas
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Set temporary canvas dimensions
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Copy current image to temporary canvas
            tempCtx.drawImage(canvas, 0, 0);
            
            // Get image data
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // Apply filter
            for (let i = 0; i < data.length; i += 4) {
                // Convert RGB to HSL
                let [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
                
                // Apply filter values
                if (filter.values.brightness !== undefined) {
                    l = Math.max(0, Math.min(1, l + filter.values.brightness / 200));
                }
                
                if (filter.values.contrast !== undefined) {
                    if (filter.values.contrast > 0) {
                        l = (l - 0.5) * (1 - filter.values.contrast / 100) + 0.5;
                    } else {
                        l = (l - 0.5) * (1 + filter.values.contrast / 100) + 0.5;
                    }
                }
                
                if (filter.values.saturation !== undefined) {
                    s = Math.max(0, Math.min(1, s * (1 + filter.values.saturation / 100)));
                }
                
                if (filter.values.grayscale !== undefined) {
                    s = Math.max(0, s * (1 - filter.values.grayscale / 100));
                }
                
                if (filter.values.sepia !== undefined && filter.values.sepia > 0) {
                    // Apply sepia tone
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    data[i] = Math.min(255, (r * (1 - 0.607 * filter.values.sepia / 100)) + (g * 0.769 * filter.values.sepia / 100) + (b * 0.189 * filter.values.sepia / 100));
                    data[i + 1] = Math.min(255, (r * 0.349 * filter.values.sepia / 100) + (g * (1 - 0.314 * filter.values.sepia / 100)) + (b * 0.168 * filter.values.sepia / 100));
                    data[i + 2] = Math.min(255, (r * 0.272 * filter.values.sepia / 100) + (g * 0.534 * filter.values.sepia / 100) + (b * (1 - 0.869 * filter.values.sepia / 100)));
                    
                    continue; // Skip HSL conversion back
                }
                
                if (filter.values.hue !== undefined) {
                    h = (h + filter.values.hue / 360) % 1;
                }
                
                // Convert HSL back to RGB
                const [r, g, b] = hslToRgb(h, s, l);
                
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
            
            // Apply blur if needed
            if (filter.values.blur !== undefined && filter.values.blur > 0) {
                applyBlur(imageData, filter.values.blur);
            }
            
            // Draw filtered image
            ctx.putImageData(imageData, 0, 0);
            
            // Save to history if not in preview mode
            if (!previewMode) {
                saveToHistory();
            }
        }
        
        // Add text to canvas
        function addTextToCanvas() {
            const text = document.getElementById('textInput').value;
            const fontFamily = document.getElementById('fontFamily').value;
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const fontColor = document.getElementById('fontColor').value;
            
            // Get text style
            let fontWeight = 'normal';
            let fontStyle = 'normal';
            let textDecoration = 'none';
            
            if (document.getElementById('boldBtn').classList.contains('active')) {
                fontWeight = 'bold';
            }
            
            if (document.getElementById('italicBtn').classList.contains('active')) {
                fontStyle = 'italic';
            }
            
            if (document.getElementById('underlineBtn').classList.contains('active')) {
                textDecoration = 'underline';
            }
            
            // Create text object
            const textObj = {
                text: text,
                x: canvas.width / 2,
                y: canvas.height / 2,
                fontFamily: fontFamily,
                fontSize: fontSize,
                fontColor: fontColor,
                fontWeight: fontWeight,
                fontStyle: fontStyle,
                textDecoration: textDecoration,
                rotation: 0
            };
            
            // Add text object to array
            textObjects.push(textObj);
            
            // Draw text on canvas
            drawText(textObj);
            
            // Save to history
            saveToHistory();
            
            // Hide text modal
            textModal.classList.add('hidden');
            
            // Setup text editing
            setupTextEditing();
        }
        
        // Draw text on canvas
        function drawText(textObj) {
            ctx.save();
            
            // Set font properties
            ctx.font = `${textObj.fontWeight} ${textObj.fontStyle} ${textObj.fontSize}px ${textObj.fontFamily}`;
            ctx.fillStyle = textObj.fontColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Apply rotation
            if (textObj.rotation !== 0) {
                ctx.translate(textObj.x, textObj.y);
                ctx.rotate((textObj.rotation * Math.PI) / 180);
                ctx.fillText(textObj.text, 0, 0);
            } else {
                ctx.fillText(textObj.text, textObj.x, textObj.y);
            }
            
            ctx.restore();
        }
        
        // Setup text editing
        function setupTextEditing() {
            canvas.style.cursor = 'move';
            
            canvas.addEventListener('mousedown', startTextDrag);
            canvas.addEventListener('mousemove', updateTextDrag);
            canvas.addEventListener('mouseup', endTextDrag);
        }
        
        // Start text dragging
        function startTextDrag(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            
            // Check if mouse is over any text
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const textObj = textObjects[i];
                
                ctx.save();
                ctx.font = `${textObj.fontWeight} ${textObj.fontStyle} ${textObj.fontSize}px ${textObj.fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const metrics = ctx.measureText(textObj.text);
                const textWidth = metrics.width;
                const textHeight = textObj.fontSize;
                
                ctx.restore();
                
                // Calculate text bounds
                const x = textObj.x - textWidth / 2;
                const y = textObj.y - textHeight / 2;
                const width = textWidth;
                const height = textHeight;
                
                // Check if mouse is inside text bounds
                if (mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height) {
                    selectedTextIndex = i;
                    isDragging = true;
                    return;
                }
            }
            
            selectedTextIndex = -1;
        }
        
        // Update text dragging
        function updateTextDrag(e) {
            if (!isDragging || selectedTextIndex === -1) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            
            // Update text position
            textObjects[selectedTextIndex].x = mouseX;
            textObjects[selectedTextIndex].y = mouseY;
            
            // Redraw canvas
            redrawCanvas();
        }
        
        // End text dragging
        function endTextDrag() {
            if (!isDragging) return;
            
            isDragging = false;
            
            if (selectedTextIndex !== -1) {
                // Save to history
                saveToHistory();
                selectedTextIndex = -1;
            }
        }
        
        // Simulate AI background removal
        function simulateAiBackgroundRemove() {
            // Hide AI modal
            aiModal.classList.add('hidden');
            
            // Show loading overlay
            loadingOverlay.classList.remove('hidden');
            loadingText.textContent = 'Removing background with AI...';
            
            // Simulate AI processing
            setTimeout(() => {
                // Create temporary canvas
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Set temporary canvas dimensions
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                
                // Copy current image to temporary canvas
                tempCtx.drawImage(canvas, 0, 0);
                
                // Get image data
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                
                // Simple background removal simulation (replace with actual AI in production)
                for (let i = 0; i < data.length; i += 4) {
                    // Convert to grayscale
                    const gray = 0.2989 * data[i] + 0.5870 * data[i + 1] + 0.1140 * data[i + 2];
                    
                    // If pixel is light (likely background), make it transparent
                    if (gray > 200) {
                        data[i + 3] = 0; // Set alpha to 0 (transparent)
                    }
                }
                
                // Create new canvas with transparent background
                canvas.width = tempCanvas.width;
                canvas.height = tempCanvas.height;
                
                // Draw image with transparent background
                ctx.putImageData(imageData, 0, 0);
                
                // Save to history
                saveToHistory();
                
                // Hide loading overlay
                loadingOverlay.classList.add('hidden');
                
                // Hide properties panel
                propertiesPanel.classList.add('hidden');
            }, 2000);
        }
        
        // Show export modal
        function show匯出Modal() {
            exportModal.classList.remove('hidden');
        }
        
        // Update quality slider visibility based on format
        function updateQualityVisibility() {
            const format = document.getElementById('exportFormat').value;
            const qualityContainer = document.getElementById('exportQuality').parentElement;
            
            if (format === 'image/jpeg') {
                qualityContainer.classList.remove('hidden');
            } else {
                qualityContainer.classList.add('hidden');
            }
        }
        
        // Update quality value display
        function updateQualityValue() {
            const quality = document.getElementById('exportQuality').value;
            document.getElementById('qualityValue').textContent = `${Math.round(quality * 100)}%`;
        }
        
        // 匯出 image
        function exportImage() {
            const format = document.getElementById('exportFormat').value;
            const quality = parseFloat(document.getElementById('exportQuality').value);
            
            // Create temporary canvas for export
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            // Set export canvas dimensions
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            
            // Fill with white background (for JPEG)
            if (format === 'image/jpeg') {
                exportCtx.fillStyle = '#ffffff';
                exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            }
            
            // Draw current image
            exportCtx.drawImage(canvas, 0, 0);
            
            // Create download link
            const link = document.createElement('a');
            link.download = `pixelcraft-${Date.now()}.${format.split('/')[1]}`;
            link.href = exportCanvas.toDataURL(format, quality);
            
            // Trigger download
            link.click();
            
            // Hide export modal
            exportModal.classList.add('hidden');
        }
        
        // Save current state to history
        function saveToHistory() {
            // Remove any future states if we're not at the end of the history
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            // Save current canvas state
            history.push(canvas.toDataURL());
            historyIndex = history.length - 1;
            
            // Update undo/redo buttons
            updateHistoryButtons();
        }
        
        // 復原 last action
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadFromHistory();
            }
        }
        
        // 重做 last undone action
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadFromHistory();
            }
        }
        
        // Load state from history
        function loadFromHistory() {
            const img = new Image();
            
            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                
                // Update undo/redo buttons
                updateHistoryButtons();
            };
            
            img.src = history[historyIndex];
        }
        
        // Update undo/redo button states
        function updateHistoryButtons() {
            const undoBtn = document.querySelector('.tool-button[data-tool="undo"]');
            const redoBtn = document.querySelector('.tool-button[data-tool="redo"]');
            
            undoBtn.classList.toggle('opacity-50', historyIndex <= 0);
            redoBtn.classList.toggle('opacity-50', historyIndex >= history.length - 1);
        }
        
        // 重置 to original image
        function resetToOriginal() {
            if (originalImage) {
                canvas.width = originalImage.width;
                canvas.height = originalImage.height;
                ctx.drawImage(originalImage, 0, 0);
                
                // Clear text objects
                textObjects = [];
                
                // Save to history
                saveToHistory();
                
                // Hide properties panel
                propertiesPanel.classList.add('hidden');
            }
        }
        
        // Redraw canvas with all elements
        function redrawCanvas() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw image
            if (currentImage) {
                ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            }
            
            // Draw all text objects
            textObjects.forEach(textObj => {
                drawText(textObj);
            });
        }
        
        // Apply blur effect to image data
        function applyBlur(imageData, blurAmount) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            // Create temporary array to store pixel data
            const tempData = new Uint8ClampedArray(data);
            
            // Blur kernel size
            const kernelSize = Math.floor(blurAmount) * 2 + 1;
            const kernelRadius = Math.floor(kernelSize / 2);
            
            // Apply blur
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0;
                    let count = 0;
                    
                    // Sample surrounding pixels
                    for (let ky = -kernelRadius; ky <= kernelRadius; ky++) {
                        for (let kx = -kernelRadius; kx <= kernelRadius; kx++) {
                            const px = x + kx;
                            const py = y + ky;
                            
                            // Check if pixel is within bounds
                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const i = (py * width + px) * 4;
                                r += tempData[i];
                                g += tempData[i + 1];
                                b += tempData[i + 2];
                                a += tempData[i + 3];
                                count++;
                            }
                        }
                    }
                    
                    // Average pixel values
                    const i = (y * width + x) * 4;
                    data[i] = r / count;
                    data[i + 1] = g / count;
                    data[i + 2] = b / count;
                    data[i + 3] = a / count;
                }
            }
        }
        
        // Toggle text style (bold, italic, underline)
        function toggleTextStyle(style) {
            return function() {
                const button = document.getElementById(`${style}Btn`);
                button.classList.toggle('active');
                button.classList.toggle('bg-primary/20');
                button.classList.toggle('text-primary');
            };
        }
        
        // Convert RGB to HSL
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            return [h, s, l];
        }
        
        // Convert HSL to RGB
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>