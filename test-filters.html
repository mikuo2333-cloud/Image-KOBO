<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>测试滤镜略缩图</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .filter-preview {
            width: 100px;
            height: 100px;
            margin: 10px;
            border: 1px solid #ccc;
            display: inline-block;
        }
    </style>
</head>
<body>
    <h1 class="text-2xl font-bold mb-4">测试滤镜略缩图显示</h1>
    <p class="mb-4">此页面用于测试滤镜略缩图是否能正常显示。如果滤镜预览图能正常加载并显示不同效果，则修复成功。</p>
    
    <div id="filterContainer" class="flex flex-wrap">
        <!-- 滤镜预览将在这里动态生成 -->
    </div>
    
    <script>
        // 模拟滤镜预设
        const filterPresets = [
            { name: 'Normal', values: { brightness: 0, contrast: 0, saturation: 0, grayscale: 0, sepia: 0 } },
            { name: 'Vintage', values: { brightness: 10, contrast: -10, saturation: -20, grayscale: 0, sepia: 50 } },
            { name: 'B&W', values: { brightness: 0, contrast: 20, saturation: -100, grayscale: 100, sepia: 0 } },
            { name: 'Vibrant', values: { brightness: 10, contrast: 15, saturation: 40, grayscale: 0, sepia: 0 } },
            { name: 'Dramatic', values: { brightness: -10, contrast: 30, saturation: 10, grayscale: 0, sepia: 0 } },
            { name: 'Cool', values: { brightness: 0, contrast: 0, saturation: 0, grayscale: 0, sepia: 0, hue: 180 } },
            { name: 'Warm', values: { brightness: 10, contrast: 0, saturation: 20, grayscale: 0, sepia: 30 } },
            { name: 'Blur', values: { blur: 5 } }
        ];
        
        // 模拟RGB到HSL和HSL到RGB的转换函数
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            return [h, s, l];
        }
        
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        // 模拟模糊效果
        function applyBlur(imageData, blurAmount) {
            // 简化的模糊实现，实际应用中可能需要更复杂的算法
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const tempData = new Uint8ClampedArray(data);
            
            const radius = Math.floor(blurAmount);
            const kernelSize = radius * 2 + 1;
            const kernel = [];
            let sum = 0;
            
            // 创建高斯模糊核
            for (let i = 0; i < kernelSize; i++) {
                const x = i - radius;
                const value = Math.exp(-(x * x) / (2 * blurAmount * blurAmount));
                kernel.push(value);
                sum += value;
            }
            
            // 归一化核
            for (let i = 0; i < kernelSize; i++) {
                kernel[i] /= sum;
            }
            
            // 水平方向应用模糊
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0;
                    
                    for (let k = -radius; k <= radius; k++) {
                        const xOffset = Math.min(Math.max(x + k, 0), width - 1);
                        const index = (y * width + xOffset) * 4;
                        const weight = kernel[k + radius];
                        
                        r += tempData[index] * weight;
                        g += tempData[index + 1] * weight;
                        b += tempData[index + 2] * weight;
                        a += tempData[index + 3] * weight;
                    }
                    
                    const index = (y * width + x) * 4;
                    data[index] = r;
                    data[index + 1] = g;
                    data[index + 2] = b;
                    data[index + 3] = a;
                }
            }
            
            // 垂直方向应用模糊
            tempData.set(data);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0;
                    
                    for (let k = -radius; k <= radius; k++) {
                        const yOffset = Math.min(Math.max(y + k, 0), height - 1);
                        const index = (yOffset * width + x) * 4;
                        const weight = kernel[k + radius];
                        
                        r += tempData[index] * weight;
                        g += tempData[index + 1] * weight;
                        b += tempData[index + 2] * weight;
                        a += tempData[index + 3] * weight;
                    }
                    
                    const index = (y * width + x) * 4;
                    data[index] = r;
                    data[index + 1] = g;
                    data[index + 2] = b;
                    data[index + 3] = a;
                }
            }
        }
        
        // 修复后的滤镜应用函数
        function applyFilterToImage(imgElement, filter) {
            // 检查是否已经处理过这个滤镜，避免重复处理
            if (imgElement.dataset.processedFilter === JSON.stringify(filter)) {
                return;
            }
            
            const tempImg = new Image();
            tempImg.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = 100;
                canvas.height = 100;
                
                // 绘制图像到临时画布
                ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Apply filter
                for (let i = 0; i < data.length; i += 4) {
                    // Convert RGB to HSL
                    let [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    
                    // Apply filter values
                    if (filter.values.brightness !== undefined) {
                        l = Math.max(0, Math.min(1, l + filter.values.brightness / 200));
                    }
                    
                    if (filter.values.contrast !== undefined) {
                        if (filter.values.contrast > 0) {
                            l = (l - 0.5) * (1 - filter.values.contrast / 100) + 0.5;
                        } else {
                            l = (l - 0.5) * (1 + filter.values.contrast / 100) + 0.5;
                        }
                    }
                    
                    if (filter.values.saturation !== undefined) {
                        s = Math.max(0, Math.min(1, s * (1 + filter.values.saturation / 100)));
                    }
                    
                    if (filter.values.grayscale !== undefined) {
                        s = Math.max(0, s * (1 - filter.values.grayscale / 100));
                    }
                    
                    if (filter.values.sepia !== undefined && filter.values.sepia > 0) {
                        // Apply sepia tone
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        data[i] = Math.min(255, (r * (1 - 0.607 * filter.values.sepia / 100)) + (g * 0.769 * filter.values.sepia / 100) + (b * 0.189 * filter.values.sepia / 100));
                        data[i + 1] = Math.min(255, (r * 0.349 * filter.values.sepia / 100) + (g * (1 - 0.314 * filter.values.sepia / 100)) + (b * 0.168 * filter.values.sepia / 100));
                        data[i + 2] = Math.min(255, (r * 0.272 * filter.values.sepia / 100) + (g * 0.534 * filter.values.sepia / 100) + (b * (1 - 0.869 * filter.values.sepia / 100)));
                        
                        continue; // Skip HSL conversion back
                    }
                    
                    if (filter.values.hue !== undefined) {
                        h = (h + filter.values.hue / 360) % 1;
                    }
                    
                    // Convert HSL back to RGB
                    const [r, g, b] = hslToRgb(h, s, l);
                    
                    data[i] = r;
                    data[i + 1] = g;
                    data[i + 2] = b;
                }
                
                // Apply blur if needed
                if (filter.values.blur !== undefined && filter.values.blur > 0) {
                    applyBlur(imageData, filter.values.blur);
                }
                
                // Draw filtered image
                ctx.putImageData(imageData, 0, 0);
                
                // 标记此滤镜已处理
                imgElement.dataset.processedFilter = JSON.stringify(filter);
                
                // Update preview image with filtered result
                imgElement.src = canvas.toDataURL();
                
                // 显示处理完成的消息
                const statusElement = document.getElementById(`status-${imgElement.dataset.filterIndex}`);
                if (statusElement) {
                    statusElement.textContent = '✓ 处理完成';
                    statusElement.className = 'text-green-600';
                }
            };
            
            // 设置临时图像的源为原始图像数据
            tempImg.src = imgElement.dataset.originalSrc || imgElement.src;
            
            // 保存原始图像数据，以便后续处理
            if (!imgElement.dataset.originalSrc) {
                imgElement.dataset.originalSrc = imgElement.src;
            }
        }
        
        // 创建测试图像
        function createTestImage() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 100;
            canvas.height = 100;
            
            // 绘制一个简单的测试图像
            ctx.fillStyle = '#3498db';
            ctx.fillRect(0, 0, 100, 100);
            
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(50, 50, 30, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(30, 30, 40, 40);
            
            return canvas.toDataURL();
        }
        
        // 初始化测试
        function initTest() {
            const container = document.getElementById('filterContainer');
            const testImageSrc = createTestImage();
            
            filterPresets.forEach((filter, index) => {
                const filterDiv = document.createElement('div');
                filterDiv.className = 'text-center';
                
                const img = document.createElement('img');
                img.src = testImageSrc;
                img.className = 'filter-preview';
                img.dataset.filterIndex = index;
                
                const nameDiv = document.createElement('div');
                nameDiv.textContent = filter.name;
                nameDiv.className = 'font-medium';
                
                const statusDiv = document.createElement('div');
                statusDiv.id = `status-${index}`;
                statusDiv.textContent = '处理中...';
                statusDiv.className = 'text-sm text-gray-500';
                
                filterDiv.appendChild(img);
                filterDiv.appendChild(nameDiv);
                filterDiv.appendChild(statusDiv);
                container.appendChild(filterDiv);
                
                // 应用滤镜
                setTimeout(() => {
                    applyFilterToImage(img, filter);
                }, index * 200); // 错开处理时间，避免同时处理所有图像
            });
        }
        
        // 页面加载完成后初始化测试
        window.addEventListener('load', initTest);
    </script>
</body>
</html>